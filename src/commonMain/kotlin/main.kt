import com.soywiz.korev.*
import com.soywiz.korge.*
import com.soywiz.korge.animate.*
import com.soywiz.korge.input.*
import com.soywiz.korge.view.*
import com.soywiz.korge.view.Circle
import com.soywiz.korim.color.*
import com.soywiz.korma.geom.*
import com.soywiz.korio.async.*
import kotlinx.coroutines.*


/**
 * Circle Control!
 * Control a circle (the player) using the keyboard with separation of logical game state, animation and user interaction.
 * For this we need a logical game [State] (position of circle on a grid) and a representation of this game state, eg the [playerView].
 * The keyboard input should be mapped to [UserAction]s, which are then transformed to [Transition]s of the state.
 * The transitions include [AnimationStep]s which are displayed asynchronously.
 */

/**
 * The logical game state. [checkAcceptableMove] checks the game logic. (model)
 */
class State(val playerPosition: PointInt, val fencePositions: Set<PointInt>)
fun checkAcceptableMove(state: State, newPosition: PointInt) = newPosition !in state.fencePositions

// todo there should be a trace of operations to communicate how to get to the next state
// eg moving the player to a new position and change of lifepoints or something similar
// those operations would then be converted to animationsteps which then get displayed
// checkAcceptableMove could return

/**
 * User action, generated by user input in [main]
 */
sealed class UserAction {
    class MovePlayer(val direction: Direction) : UserAction()
}

enum class Direction {
    LEFT, RIGHT, UP, DOWN
}

/**
 * Instantiate the logical and visual state
 */
var state = State(
    playerPosition = PointInt(4, 4),
    fencePositions = (0..10).flatMap { row ->
        (0..10).mapNotNull { col ->
            if (row in 1..9 && col in 1..9) null else PointInt(row, col)
        }
    }.toSet()
)

/**
 * (view)
 */
const val tileSize = 20.0
val playerView = Circle(tileSize / 2, Colors.RED).xy(mapGridPositionToViewPosition(state.playerPosition))
val fenceViews =
    state.fencePositions.map { SolidRect(tileSize, tileSize, Colors.BLUE).xy(mapGridPositionToViewPosition(it)) }


suspend fun main() = Korge(width = 512, height = 512, bgcolor = Colors["#2b2b2b"]) {

    fenceViews.forEach { addChild(it) }
    addChild(playerView)

    keys {
        down { key ->
            when (key.key) {
                Key.DOWN -> gameLoopStep(UserAction.MovePlayer(Direction.DOWN))
                Key.UP -> gameLoopStep(UserAction.MovePlayer(Direction.UP))
                Key.LEFT -> gameLoopStep(UserAction.MovePlayer(Direction.LEFT))
                Key.RIGHT -> gameLoopStep(UserAction.MovePlayer(Direction.RIGHT))
                else -> {}
            }
        }
    }

}

/**
 * Tying together user actions, state changes and animation. (controller)
 */
suspend fun Stage.gameLoopStep(userAction: UserAction) {
    val transition = applyUserAction(state, userAction)
    launchImmediately {
        animateOperations(transition.animationsSteps)
    }
    state = transition.next
}

fun applyUserAction(state: State, action: UserAction): Transition {
    return when (action) {
        is UserAction.MovePlayer -> {
            val newPlayerPosition = state.playerPosition.move(action.direction)
            if (checkAcceptableMove(state, newPlayerPosition)) {
                Transition(
                    state,
                    State(newPlayerPosition, state.fencePositions),
                    listOf(AnimationsStep.MovePlayerTo(newPlayerPosition))
                )
            } else {
                Transition(
                    state,
                    state,
                    listOf(
                        AnimationsStep.MovePlayerTo(newPlayerPosition),
                        AnimationsStep.MovePlayerTo(state.playerPosition)
                    )
                )
            }
        }
    }
}

class Transition(
// todo not sure what the previous state is for
    val prev: State,
    val next: State,
    val animationsSteps: List<AnimationsStep>,
)

sealed class AnimationsStep {
    class MovePlayerTo(val position: PointInt) : AnimationsStep()
}

fun PointInt.move(direction: Direction): PointInt {
    return this + when (direction) {
        Direction.LEFT -> PointInt(-1, 0)
        Direction.RIGHT -> PointInt(1, 0)
        Direction.UP -> PointInt(0, -1)
        Direction.DOWN -> PointInt(0, 1)
    }
}

fun mapGridPositionToViewPosition(position: PointInt): Point {
    return Point(position.x * tileSize, position.y * tileSize)
}

suspend fun Stage.animateOperations(animationsSteps: List<AnimationsStep>) {
    animate {
        sequence {
            animationsSteps.forEach { animationStep ->
                when (animationStep) {
                    is AnimationsStep.MovePlayerTo -> {
                        val (x, y) = mapGridPositionToViewPosition(animationStep.position)
                        moveTo(playerView, x, y)
                    }
                }
            }
        }
    }
}
